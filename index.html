<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ocorrências por Região</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://unpkg.com/leaflet-omnivore@0.3.4/leaflet-omnivore.min.js"></script>

  <style>
    :root{
      --bg:#ffffff;
      --panel:#f5f7fb;
      --text:#0b1020;
      --muted:#5b6b82;
      --border:#e9eef7;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial;
      overflow-x:hidden;
    }

    .app {
      display:grid;
      grid-template-rows:auto 1fr auto;
      height:100%;
    }

    header {
      display:flex;
      flex-wrap:wrap;
      gap:16px;
      align-items:center;
      padding:12px 16px;
      background:var(--panel);
      box-shadow:0 2px 12px rgba(0,0,0,.08);
      position:sticky;
      top:0;
      z-index:1000;
    }

    .title-block {
      display:flex;
      flex-direction:column;
      align-items:flex-start;
    }

    .title-block h1 {
      margin:0;
      font-size:18px;
      letter-spacing:.2px;
    }

    .title-block .fonte {
      font-size:12px;
      margin-top:2px;
      color:#4b5563;
    }

    .controls {
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      font-size:14px;
      color:var(--muted);
    }

    .badge {
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      background:#eef2f9;
    }

    .select {
      padding:6px 10px;
      border:1px solid #dbe3f0;
      border-radius:8px;
      background:#fff;
      color:#0b1020;
    }

    #map { height:100%; }

    .legend {
      position:absolute;
      background:rgba(255,255,255,0.98);
      color:#111827;
      padding:2px 12px;
      border-radius:10px;
      font:12px system-ui;
      z-index:500;
      border:1px solid var(--border);
      bottom:60px;
      right:10px;
    }

    .legend .row { display:flex; align-items:center; gap:8px; margin:4px 0; }
    .legend .dot { width:14px; height:14px; border-radius:4px; background:#1976d2; }

    /* NOVA LEGENDA RECOLHÍVEL */
    .color-legend {
      position:absolute;
      bottom:145px;
      right:10px;
      width:320px;
      max-height:350px;
      background:rgba(255,255,255,0.98);
      border:1px solid var(--border);
      border-radius:10px;
      padding:6px 12px 10px 12px;
      box-shadow:0 4px 14px rgba(0,0,0,0.15);
      overflow:hidden;
      transition:max-height 0.25s ease-in-out, padding 0.25s ease-in-out;
      z-index:600;
      display:flex;
      flex-direction:column;
    }

    .color-legend.collapsed {
      max-height:32px;
      padding-top:4px;
      padding-bottom:4px;
    }

    .color-legend-header {
      display:flex;
      justify-content:space-between;
      align-items:center;
      cursor:pointer;
      font-size:14px;
      font-weight:600;
      user-select:none;
    }

    .color-legend-header button {
      background:none;
      border:none;
      font-size:18px;
      cursor:pointer;
      padding:0;
      line-height:1;
    }

    .color-legend .items {
      margin-top:8px;
      flex:1;
      max-height:none;
      overflow-y:auto;
      display:flex;
      flex-wrap:wrap;
      gap:4px 12px;
      font-size: 11px;
    }

    .color-legend.collapsed .items {
      display:none;
    }

    .color-legend .item {
      display:flex;
      align-items:center;
      gap:8px;
      margin:2px 0;
    }

    .color-legend .box {
      width:14px;
      height:14px;
      border-radius:3px;
    }

    .color-legend.two-cols .item { width:48%; }

    .timeline {
      position:fixed;
      left:20px;
      right:20px;
      bottom:16px;
      z-index:1000;
      padding:10px 16px;
      background:transparent;
    }

    .timeline .label {
      margin:0 0 8px 2px;
      color:#1976d2;
      font:700 13px system-ui;
      text-shadow:0 1px 2px rgba(255,255,255,0.6);
    }

    .timeline .track {
      position:relative;
      height:8px;
      background:#1976d2;
      border-radius:999px;
      box-shadow:inset 0 0 0 2px rgba(255,255,255,0.8);
    }

    .timeline .handle {
      position:absolute;
      top:50%;
      transform:translate(-50%, -50%);
      width:20px;
      height:20px;
      border-radius:50%;
      background:#0d47a1;
      border:2px solid #bbdefb;
      box-shadow:0 2px 8px rgba(0,0,0,0.35);
      cursor:grab;
    }

    .timeline .ticks {
      display:flex;
      justify-content:space-between;
      margin-top:6px;
      color:#1976d2;
      font:700 12px/1 system-ui;
      text-shadow:0 1px 2px rgba(255,255,255,0.6);
    }

    .timeline .year { user-select:none; }

    .kml-busy {
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      background:rgba(0,0,0,0.75);
      color:#fff;
      padding:8px 12px;
      border-radius:8px;
      display:none;
      z-index:700;
    }

    .leaflet-popup-content-wrapper {
      border-radius:14px;
      box-shadow:0 10px 30px rgba(0,0,0,.15);
    }

    .leaflet-popup-content {
      margin:12px 16px;
    }

    table.minimal {
      border-collapse:collapse;
      width:100%;
      font-size:12px;
    }

    table.minimal th,
    table.minimal td {
      border-bottom:1px solid #eee;
      padding:4px 6px;
      text-align:left;
    }

    .region-pill-wrapper { pointer-events:none; }

    .region-pill {
      background:#ffffff;
      border-radius:999px;
      padding:2px 8px;
      font-size:11px;
      font-weight:600;
      color:#111827;
      border:1px solid rgba(15,23,42,0.08);
      box-shadow:0 1px 4px rgba(15,23,42,0.35);
      white-space:nowrap;
    }
  
    /* CONVENÇÕES (CORES DOS PONTOS POR HORÁRIO) */
    .color-legend .conv {
      margin-top:8px;
      padding-top:8px;
      border-top:1px solid var(--border);
      font-size:11px;
    }
    .color-legend .conv-title{
      font-weight:700;
      margin:0 0 6px;
      color:#111827;
    }
    .color-legend .conv-items{
      display:flex;
      flex-wrap:wrap;
      gap:4px 12px;
    }
    .color-legend .conv-item{
      display:flex;
      align-items:center;
      gap:8px;
      margin:2px 0;
      width:48%;
    }
    .color-legend.collapsed .conv{
      display:none;
    }

    .time-filters{
      padding: 6px 8px;
      border-top: 1px solid #e5e7eb;
      border-bottom: 1px solid #e5e7eb;
      background: rgba(255,255,255,0.92);
    }
    .time-filters .tf-title{
      font-weight: 800;
      font-size: 11px;
      margin-bottom: 4px;
      color: #111827;
      letter-spacing: .2px;
    }
    
    .time-filters .tf-row{
      display:flex;
      align-items:center;
      gap: 8px;
      flex-wrap:nowrap;
      white-space:nowrap;
      overflow-x:auto;
      padding-bottom: 0px;
    }
    .time-filters .tf-row::-webkit-scrollbar{ height: 6px; }
    .time-filters .tf-row::-webkit-scrollbar-thumb{ background: rgba(17,24,39,0.18); border-radius: 999px; }
    .time-filters .tf-row::-webkit-scrollbar-track{ background: transparent; }

    .time-filters .chip{
      display:inline-flex;
      align-items:center;
      gap: 6px;
      border-radius:999px;
      padding: 4px 8px;
      font-size: 11px;
      line-height:1;
      border:1px solid rgba(17,24,39,0.18);
      background: rgba(255,255,255,0.92);
      color:#111827;
      cursor:pointer;
      user-select:none;
      transition: transform .06s ease, background .15s ease, border-color .15s ease, box-shadow .15s ease;
      flex: 0 0 auto;
    }
    .time-filters .chip:hover{ transform: translateY(-1px); }
    .time-filters .chip:active{ transform: translateY(0px); }
    .time-filters .chip:focus-visible{
      outline: none;
      box-shadow: 0 0 0 3px rgba(37,99,235,0.22);
      border-color: rgba(37,99,235,0.55);
    }
    .time-filters .chip.active{
      background: rgba(37,99,235,0.10);
      border-color: rgba(37,99,235,0.55);
      box-shadow: inset 0 0 0 1px rgba(37,99,235,0.15);
      font-weight: 700;
    }
    .time-filters .chip-all{
      font-weight: 800;
    }

    .time-filters .swatch{
      width: 10px;
      height: 10px;
      border-radius: 3px;
      border: 1px solid rgba(0,0,0,0.18);
      display:inline-block;
      flex: 0 0 auto;
    }

    /* Oculta o título em telas menores */
    @media (max-width: 720px){
      header .time-filters .tf-title{ display:none; }
      header .time-filters{ padding-top:10px; }
    }

    header .time-filters{
      width:100%;
      margin-top: 6px;
      border:0;
      border-radius: 12px;
      background:#eef2f9;
      box-shadow: inset 0 0 0 1px #dbe3f0;
    }
    header .time-filters .tf-title{
      color:#374151;
    }

    .ms{
      position: relative;
      display:inline-block;
      width: 220px;
      max-width: 220px;
    }
    .ms-btn{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(17,24,39,0.18);
      background:#fff;
      color:#111827;
      font-size:13px;
      line-height:1.1;
      cursor:pointer;
      box-shadow: 0 1px 0 rgba(17,24,39,0.04);
      user-select:none;
    }
    .ms-btn:focus-visible{
      outline:none;
      box-shadow: 0 0 0 3px rgba(37,99,235,0.18);
      border-color: rgba(37,99,235,0.55);
    }
    .ms-label{
      display:flex;
      align-items:center;
      gap:8px;
      min-width:0;
    }
    .ms-label .ms-title{
      font-weight:700;
      color:#374151;
      white-space:nowrap;
    }
    .ms-label .ms-value{
      color:#111827;
      font-weight:600;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width: 280px;
    }
    .ms-caret{
      opacity:.7;
      font-size:12px;
    }
    .ms-panel{
      position:absolute;
      top: calc(100% + 6px);
      left:0;
      z-index: 2000;
      width: 340px;
      max-width: min(200px, 80vw);
      padding:10px;
      border-radius:14px;
      border:1px solid rgba(17,24,39,0.14);
      background: rgba(255,255,255,0.98);
      box-shadow: 0 10px 30px rgba(0,0,0,0.12);
      display:none;
    }
    .ms.open .ms-panel{ display:block; }
    .ms-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:6px 6px;
      border-radius:10px;
      cursor:pointer;
      user-select:none;
    }
    .ms-row:hover{ background: rgba(37,99,235,0.06); }
    .ms-left{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }
    .ms-swatch{
      width:10px;
      height:10px;
      border-radius:3px;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.25);
      flex:0 0 auto;
    }
    .ms-text{
      font-size:13px;
      color:#111827;
      font-weight:600;
      white-space:nowrap;
    }
    .ms-row input{
      width:16px;
      height:16px;
      accent-color: #2563eb;
      flex:0 0 auto;
    }
    .ms-help{
      margin-top:8px;
      font-size:12px;
      color:#6b7280;
    }
    #timeFilters{ display:none !important; }

    #timeMs{ display:none; }

    .ms-btn{ box-sizing:border-box; }
    .ms-label{ flex: 1 1 auto; min-width:0; }
    .ms-label .ms-title{ flex: 0 0 auto; }
    .ms-label .ms-value{ flex: 1 1 auto; max-width: 120px; }

</style>
</head>

<body>
  <div class="app">
    <header>
      <div class="title-block">
        <h1>Segurança Pública no Pará (Ocorrências por Distrito/Bairro)</h1>
        <span class="fonte">Fonte: SEGUP - Secretaria de Estado de Segurança Pública e Defesa Social (2020-11/2025).</span>
      </div>
      <div class="controls">
        <label class="badge">Tipo:
          <select id="tipoSel" class="select">
            <option value="__all__">Todas</option>
            <option value="estupro_com_resultado_morte">Estupro com resultado morte</option>
            <option value="estupro_de_vulneravel_com_resultado_morte">Estupro de vulnerável com resultado morte</option>
            <option value="estupro_de_vulneravel">Estupro de vulnerável</option>
            <option value="estupro">Estupro</option>
            <option value="extorsao_mediante_sequestro_com_resultado_morte">Extorsão mediante sequestro com resultado morte</option>
            <option value="feminicidio">Feminicídio</option>
            <option value="furto">Furto</option>
            <option value="homicidio_culposo_no_transito">Homicídio culposo no trânsito</option>
            <option value="homicidio">Homicídio</option>
            <option value="latrocinio">Latrocínio</option>
            <option value="lesao_corporal_seguida_de_morte">Lesão corporal seguida de morte</option>
            <option value="lesao_corporal">Lesão corporal</option>
            <option value="maus_tratos_com_resultado_morte">Maus-tratos com resultado morte</option>
            <option value="morte_no_transito">Morte no trânsito</option>
            <option value="roubo">Roubo</option>
            <option value="trafico_de_drogas">Tráfico de drogas</option>
          </select>
        </label>

        <label class="badge">Ano:
          <select id="anoSel" class="select"></select>
        </label>

        <label class="badge">Distrito:
          <select id="distritoSel" class="select">
            <option value="__all__">Todos</option>
          </select>
        </label>

        <label class="badge">Bairro:
          <select id="bairroSel" class="select">
            <option value="__all__">Todos</option>
          </select>
        </label>

        <div class="ms" id="timeMs" title="Filtrar pontos por faixa de horário (permite múltipla seleção)">
          <button type="button" class="ms-btn" id="timeMsBtn" aria-haspopup="true" aria-expanded="false">
            <span class="ms-label">
              <span class="ms-title">Horários:</span>
              <span class="ms-value" id="timeMsValue">Todas</span>
            </span>
            <span class="ms-caret">▾</span>
          </button>
          <div class="ms-panel" id="timeMsPanel" role="menu" aria-label="Selecionar faixas de horário">
            <div class="ms-row" data-ms="all">
              <div class="ms-left">
                <span class="ms-text">Todas</span>
              </div>
              <input type="checkbox" id="ms_all" checked />
            </div>

            <div class="ms-row" data-ms="yellow">
              <div class="ms-left">
                <span class="ms-swatch" style="background:#ffeb3b"></span>
                <span class="ms-text">00:01–06:00</span>
              </div>
              <input type="checkbox" id="ms_yellow" checked />
            </div>

            <div class="ms-row" data-ms="green">
              <div class="ms-left">
                <span class="ms-swatch" style="background:#8bc34a"></span>
                <span class="ms-text">06:01–12:00</span>
              </div>
              <input type="checkbox" id="ms_green" checked />
            </div>

            <div class="ms-row" data-ms="orange">
              <div class="ms-left">
                <span class="ms-swatch" style="background:#ff9800"></span>
                <span class="ms-text">12:01–18:00</span>
              </div>
              <input type="checkbox" id="ms_orange" checked />
            </div>

            <div class="ms-row" data-ms="red">
              <div class="ms-left">
                <span class="ms-swatch" style="background:#ff0000"></span>
                <span class="ms-text">18:01–00:00</span>
              </div>
              <input type="checkbox" id="ms_red" checked />
            </div>

            <div class="ms-help">Dica: você pode marcar mais de uma faixa.</div>
          </div>
        </div>

<div class="ms" id="monthMs" style="display:none" title="Filtrar pontos por mês (permite múltipla seleção)">
  <button type="button" class="ms-btn" id="monthMsBtn" aria-haspopup="true" aria-expanded="false">
    <span class="ms-label">
      <span class="ms-title">Mês:</span>
      <span class="ms-value" id="monthMsValue">Todos</span>
    </span>
    <span class="ms-caret">▾</span>
  </button>
  <div class="ms-panel" id="monthMsPanel" role="menu" aria-label="Selecionar meses">
    <div class="ms-row" data-ms="all">
      <div class="ms-left">
        <span class="ms-text">Todos</span>
      </div>
      <input type="checkbox" id="mon_all" checked />
    </div>

    <div class="ms-row" data-ms="1"><div class="ms-left"><span class="ms-text">Jan</span></div><input type="checkbox" id="mon_1" checked /></div>
    <div class="ms-row" data-ms="2"><div class="ms-left"><span class="ms-text">Fev</span></div><input type="checkbox" id="mon_2" checked /></div>
    <div class="ms-row" data-ms="3"><div class="ms-left"><span class="ms-text">Mar</span></div><input type="checkbox" id="mon_3" checked /></div>
    <div class="ms-row" data-ms="4"><div class="ms-left"><span class="ms-text">Abr</span></div><input type="checkbox" id="mon_4" checked /></div>
    <div class="ms-row" data-ms="5"><div class="ms-left"><span class="ms-text">Mai</span></div><input type="checkbox" id="mon_5" checked /></div>
    <div class="ms-row" data-ms="6"><div class="ms-left"><span class="ms-text">Jun</span></div><input type="checkbox" id="mon_6" checked /></div>
    <div class="ms-row" data-ms="7"><div class="ms-left"><span class="ms-text">Jul</span></div><input type="checkbox" id="mon_7" checked /></div>
    <div class="ms-row" data-ms="8"><div class="ms-left"><span class="ms-text">Ago</span></div><input type="checkbox" id="mon_8" checked /></div>
    <div class="ms-row" data-ms="9"><div class="ms-left"><span class="ms-text">Set</span></div><input type="checkbox" id="mon_9" checked /></div>
    <div class="ms-row" data-ms="10"><div class="ms-left"><span class="ms-text">Out</span></div><input type="checkbox" id="mon_10" checked /></div>
    <div class="ms-row" data-ms="11"><div class="ms-left"><span class="ms-text">Nov</span></div><input type="checkbox" id="mon_11" checked /></div>
    <div class="ms-row" data-ms="12"><div class="ms-left"><span class="ms-text">Dez</span></div><input type="checkbox" id="mon_12" checked /></div>

    <div class="ms-help">Dica: você pode marcar mais de um mês.</div>
  </div>
</div>

        <span class="badge"><strong id="sumTotal">—</strong> total no ano</span>

        <label class="badge">
          <input type="checkbox" id="pillToggle" checked style="margin:0;">
          Mostrar contagem por bairro
        </label>

        <button id="btnReset" class="badge" style="cursor:pointer;">Limpar</button>
      </div>
      
      <div class="time-filters" id="timeFilters" style="display:none">
        <div class="tf-title" id="tfTitle">Horários (filtro dos pontos)</div>
        <div class="tf-row" id="tfRow" aria-label="Filtro por horário">
          <button type="button" class="chip chip-all active" id="tf_all" data-bucket="all" title="Exibir todas as ocorrências do bairro no ano selecionado">
            Todos
          </button>

          <button type="button" class="chip active" id="tf_yellow" data-bucket="yellow" title="00:01–06:00">
            <span class="swatch" style="background:#ffeb3b"></span>
            00:01–06:00
          </button>

          <button type="button" class="chip active" id="tf_green" data-bucket="green" title="06:01–12:00">
            <span class="swatch" style="background:#8bc34a"></span>
            06:01–12:00
          </button>

          <button type="button" class="chip active" id="tf_orange" data-bucket="orange" title="12:01–18:00">
            <span class="swatch" style="background:#ff9800"></span>
            12:01–18:00
          </button>

          <button type="button" class="chip active" id="tf_red" data-bucket="red" title="18:01–00:00">
            <span class="swatch" style="background:#ff0000"></span>
            18:01–00:00
          </button>
        </div>
      </div>

    </header>

    <div id="map"></div>

    <div class="timeline" id="timeline">
      <div class="label">Linha do tempo (arraste o marcador)</div>
      <div class="track" id="track">
        <div class="handle" id="handle" style="left:0%;"></div>
      </div>
      <div class="ticks" id="ticks"></div>
    </div>
  </div>

  <div id="busy" class="kml-busy">Carregando dados...</div>

  <div class="legend">
    <h4 style="margin:0 0 6px;">Densidade de ocorrências</h4>
    <div class="row"><span class="dot" style="opacity:0.2"></span> Baixa</div>
    <div class="row"><span class="dot" style="opacity:0.55"></span> Média</div>
    <div class="row"><span class="dot" style="opacity:0.9"></span> Alta</div>
  </div>

  <!-- NOVA LEGENDA RECOLHÍVEL -->
  <div class="color-legend" id="colorLegend">
    <div class="color-legend-header" id="legendHeader">
      <span>Bairros</span>
      <button id="legendBtn">▼</button>
    </div>
    
    <div class="items" id="colorLegendItems"></div>
    <div class="conv" id="convLegend"></div>
  </div>

  <script>
    const CSV_DIR = "data/";
    const KML_DIR = "kml_poligonos/";

    const CSV_SOURCES = [
      { key: "estupro_com_resultado_morte",                 path: CSV_DIR + "estupro_com_resultado_morte.csv",                 label: "Estupro com resultado morte" },
      { key: "estupro_de_vulneravel_com_resultado_morte",   path: CSV_DIR + "estupro_de_vulneravel_com_resultado_morte.csv",   label: "Estupro de vulnerável com resultado morte" },
      { key: "estupro_de_vulneravel",                       path: CSV_DIR + "estupro_de_vulneravel.csv",                       label: "Estupro de vulnerável" },
      { key: "estupro",                                     path: CSV_DIR + "estupro.csv",                                     label: "Estupro" },
      { key: "extorsao_mediante_sequestro_com_resultado_morte", path: CSV_DIR + "extorsao_mediante_sequestro_com_resultado_morte.csv", label: "Extorsão mediante sequestro com resultado morte" },
      { key: "feminicidio",                                 path: CSV_DIR + "feminicidio.csv",                                 label: "Feminicídio" },
      { key: "furto",                                       path: CSV_DIR + "furto.csv",                                       label: "Furto" },
      { key: "homicidio_culposo_no_transito",               path: CSV_DIR + "homicidio_culposo_no_transito.csv",               label: "Homicídio culposo no trânsito" },
      { key: "homicidio",                                   path: CSV_DIR + "homicidio.csv",                                   label: "Homicídio" },
      { key: "latrocinio",                                  path: CSV_DIR + "latrocinio.csv",                                  label: "Latrocínio" },
      { key: "lesao_corporal_seguida_de_morte",             path: CSV_DIR + "lesao_corporal_seguida_de_morte.csv",             label: "Lesão corporal seguida de morte" },
      { key: "lesao_corporal",                              path: CSV_DIR + "lesao_corporal.csv",                              label: "Lesão corporal" },
      { key: "maus_tratos_com_resultado_morte",             path: CSV_DIR + "maus_tratos_com_resultado_morte.csv",             label: "Maus-tratos com resultado morte" },
      { key: "morte_no_transito",                           path: CSV_DIR + "morte_no_transito.csv",                           label: "Morte no trânsito" },
      { key: "roubo",                                       path: CSV_DIR + "roubo.csv",                                       label: "Roubo" },
      { key: "trafico_de_drogas",                           path: CSV_DIR + "trafico_de_drogas.csv",                           label: "Tráfico de drogas" }
    ];

    const COLOR_PALETTE = [
      "#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b",
      "#e377c2","#7f7f7f","#bcbd22","#17becf"
    ];
    const COLOR_MAP = {};
    function colorForRegion(key){
      if (!COLOR_MAP[key]) {
        const idx = Object.keys(COLOR_MAP).length % COLOR_PALETTE.length;
        COLOR_MAP[key] = COLOR_PALETTE[idx];
      }
      return COLOR_MAP[key];
    }

    function normalizeName(s){
      if (!s) return "";
      return String(s)
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g,"")
        .replace(/[^A-Za-z0-9 ]+/g," ")
        .replace(/\s+/g," ")
        .trim()
        .toUpperCase();
    }

    // ------------------------------
    // Leitura robusta de colunas (CSV)
    // ------------------------------
    function getValueByNormalizedHeader(row, normalizedTargets){
      // normalizedTargets: array de strings NORMALIZADAS (normalizeName) e SEM ESPAÇOS
      try{
        if (!row) return undefined;
        const keys = Object.keys(row);
        for (const key of keys){
          const nk = normalizeName(String(key).replace(/^\uFEFF/, "")).replace(/\s+/g,"");
          if (normalizedTargets.includes(nk)) return row[key];
        }
      }catch(e){}
      return undefined;
    }

    function getMesFromRow(row){
      // Aceita: mes, mês, MES, Mes, etc.
      return getValueByNormalizedHeader(row, ["MES","MÊS","MESDOFATO","MESFATO","MESOCORRENCIA","MESOCORR"]);
    }

    // Busca valor de uma coluna aceitando variações no cabeçalho (espaços/BOM/acentos/caixa)
    function getRowValueByHeader(row, wanted){
      try{
        if (!row) return undefined;

        // 1) correspondência exata
        for (const k of wanted){
          if (Object.prototype.hasOwnProperty.call(row, k)) return row[k];
        }

        // 2) correspondência por normalização do cabeçalho
        const wantedNorm = wanted.map(w => normalizeName(w));
        const keys = Object.keys(row);
        for (const key of keys){
          const nk = normalizeName(String(key).replace(/^\uFEFF/, ""));
          if (wantedNorm.includes(nk)) return row[key];
        }
      }catch(e){}
      return undefined;
    }

    function slug(s){
      if (!s) return "";
      return String(s)
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g,"")
        .toLowerCase()
        .replace(/[^a-z0-9]+/g,"_")
        .replace(/^_+|_+$/g,"");
    }

    function parseNumber(val){
      if (val === null || val === undefined) return NaN;
      if (typeof val === "number") return val;
      let s = String(val).trim();
      if (!s) return NaN;
      if (s.indexOf(",") >= 0 && s.indexOf(".") === -1) {
        s = s.replace(",", ".");
      }
      s = s.replace(/\s+/g,"");
      const n = parseFloat(s);
      return Number.isFinite(n) ? n : NaN;
    }

    function parseTimeToSeconds(hhmmss){
      if (!hhmmss) return NaN;
      const s = String(hhmmss).trim();
      const m = s.match(/^([0-1]?\d|2[0-3]):([0-5]\d)(?::([0-5]\d))?$/);
      if (!m) return NaN;
      const h  = parseInt(m[1], 10);
      const mi = parseInt(m[2], 10);
      const se = parseInt(m[3] || "0", 10);
      return h * 3600 + mi * 60 + se;
    }

    function colorForHoraFato(hhmmss){
      // Regras:
      // amarelo:   00:01–06:00
      // verde:     06:01–12:00
      // laranja:   12:01–18:00
      // vermelho:  18:01–00:00 (inclui 00:00)
      const t = parseTimeToSeconds(hhmmss);
      if (!Number.isFinite(t)) return "#ff0000"; // fallback: vermelho

      const s00_00 = 0;
      const s00_01 = 60;
      const s06_00 = 6 * 3600;
      const s06_01 = 6 * 3600 + 60;
      const s12_00 = 12 * 3600;
      const s12_01 = 12 * 3600 + 60;
      const s18_00 = 18 * 3600;
      const s18_01 = 18 * 3600 + 60;

      if (t >= s00_01 && t <= s06_00) return "#ffeb3b";  // amarelo
      if (t >= s06_01 && t <= s12_00) return "#8bc34a";  // verde claro
      if (t >= s12_01 && t <= s18_00) return "#ff9800";  // laranja
      // 18:01–23:59:59 e 00:00
      if (t >= s18_01 || t === s00_00) return "#ff0000"; // vermelho
      return "#ff0000";
    }

    
    function bucketForHoraFato(hhmmss){
      // Retorna: 'yellow' | 'green' | 'orange' | 'red'
      const t = parseTimeToSeconds(hhmmss);
      if (!Number.isFinite(t)) return "red";

      const s00_00 = 0;
      const s00_01 = 60;
      const s06_00 = 6 * 3600;
      const s06_01 = 6 * 3600 + 60;
      const s12_00 = 12 * 3600;
      const s12_01 = 12 * 3600 + 60;
      const s18_00 = 18 * 3600;
      const s18_01 = 18 * 3600 + 60;

      if (t >= s00_01 && t <= s06_00) return "yellow";
      if (t >= s06_01 && t <= s12_00) return "green";
      if (t >= s12_01 && t <= s18_00) return "orange";
      if (t >= s18_01 || t === s00_00) return "red";
      return "red";
    }

    function getSelectedTimeBuckets(){
      // Se "Todos" estiver ativo, mostramos todas as faixas.
      // Caso contrário, retornamos apenas as faixas ativas (pode ficar vazio).
      if (tfAll && tfAll.classList.contains("active")) return ["yellow","green","orange","red"];
      const sel = [];
      if (tfYellow && tfYellow.classList.contains("active")) sel.push("yellow");
      if (tfGreen  && tfGreen.classList.contains("active"))  sel.push("green");
      if (tfOrange && tfOrange.classList.contains("active")) sel.push("orange");
      if (tfRed    && tfRed.classList.contains("active"))    sel.push("red");
      return sel; // pode ser []
    }


function getSelectedMonths(){
  if (typeof window.__getSelectedMonths === "function"){
    const v = window.__getSelectedMonths();
    return Array.isArray(v) ? v : [];
  }
  // fallback: sem UI inicializada -> todos
  return [1,2,3,4,5,6,7,8,9,10,11,12];
}

    function syncTimeFiltersUI(){
      const bairroSel = bairroSelEl.value;
      const shouldShow = (bairroSel && bairroSel !== "__all__");
      if (!timeFiltersEl) return;

      timeFiltersEl.style.display = shouldShow ? "block" : "none";

      // Ao sair do modo bairro específico, volta para "Todos"
      if (!shouldShow && tfAll){
        tfAll.classList.add("active");
        [tfYellow, tfGreen, tfOrange, tfRed].forEach(b => { if (b) b.classList.add("active"); });
      }
    }

    
    // =========================
    // MULTISELECT DE HORÁRIOS (COMBOBOX)
    // =========================
    function initTimeMultiSelect(){
      const ms = document.getElementById("timeMs");
      const btn = document.getElementById("timeMsBtn");
      const panel = document.getElementById("timeMsPanel");
      const valueEl = document.getElementById("timeMsValue");

      if (!ms || !btn || !panel || !valueEl) return;


      // Exibe o combobox apenas quando um bairro específico estiver selecionado (≠ __all__)
      function syncTimeMsVisibility(){
        const bairroSel = (typeof bairroSelEl !== "undefined" && bairroSelEl) ? bairroSelEl.value : null;
        const show = !!bairroSel && bairroSel !== "__all__";
        ms.style.display = show ? "inline-block" : "none";
        // ao esconder, fecha o painel
        if (!show){
          ms.classList.remove("open");
          btn.setAttribute("aria-expanded", "false");
        }
      }


      const cbAll = document.getElementById("ms_all");
      const cb = {
        yellow: document.getElementById("ms_yellow"),
        green: document.getElementById("ms_green"),
        orange: document.getElementById("ms_orange"),
        red: document.getElementById("ms_red"),
      };

      const rowClickToggle = (row) => {
        const key = row.getAttribute("data-ms");
        const input = row.querySelector("input[type='checkbox']");
        if (!input) return;

        // Se clicar na linha (fora do checkbox), alterna
        input.checked = !input.checked;
        onMultiSelectChanged(key);
      };

      // abre/fecha
      btn.addEventListener("click", (e) => {
        e.preventDefault();
        const open = ms.classList.toggle("open");
        btn.setAttribute("aria-expanded", open ? "true" : "false");
      });

      // fecha ao clicar fora
      document.addEventListener("click", (e) => {
        if (!ms.classList.contains("open")) return;
        if (ms.contains(e.target)) return;
        ms.classList.remove("open");
        btn.setAttribute("aria-expanded", "false");
      });

      // evita fechar quando clicar dentro do painel
      panel.addEventListener("click", (e) => {
        // Se clicou numa linha, alterna
        const row = e.target.closest(".ms-row");
        if (row && e.target.tagName !== "INPUT"){
          rowClickToggle(row);
        }
      });

      // muda pelos checkboxes
      Object.entries(cb).forEach(([k, el]) => {
        if (!el) return;
        el.addEventListener("change", () => onMultiSelectChanged(k));
      });
      if (cbAll) cbAll.addEventListener("change", () => onMultiSelectChanged("all"));

      function selectedBuckets(){
        return Object.keys(cb).filter(k => cb[k] && cb[k].checked);
      }

      function syncHiddenChips(){
        // Mantém compatibilidade: atualiza os chips existentes (mesmo ocultos)
        const chipAll = document.querySelector(".chip-all");
        const chipMap = {
          yellow: document.getElementById("tf_yellow"),
          green: document.getElementById("tf_green"),
          orange: document.getElementById("tf_orange"),
          red: document.getElementById("tf_red"),
        };

        const buckets = selectedBuckets();

        // Se "Todas" marcado ou nenhuma faixa marcada -> ativa tudo
        const allMode = (cbAll && cbAll.checked) || buckets.length === 0;

        if (chipAll){
          chipAll.classList.toggle("active", allMode);
        }
        Object.keys(chipMap).forEach(k => {
          const el = chipMap[k];
          if (!el) return;
          el.classList.toggle("active", allMode ? true : buckets.includes(k));
        });
      }

      function updateLabel(){
        const buckets = selectedBuckets();
        const allMode = (cbAll && cbAll.checked) || buckets.length === 0;
        if (allMode){
          valueEl.textContent = "Todas";
          return;
        }
        // Texto compacto para não mudar o layout do menu
        valueEl.textContent = `${buckets.length} faixa${buckets.length > 1 ? "s" : ""}`;
      }

      function enforceRules(lastKey){
  // Regras:
  // - Se marcar "Todas", todas as faixas são marcadas
  // - Se desmarcar qualquer faixa individual, "Todas" é desmarcado
  // - Se marcar as 4 faixas individualmente, "Todas" é marcado

  const buckets = selectedBuckets();

  // Clique direto em "Todas"
  if (lastKey === "all" && cbAll && cbAll.checked){
    Object.values(cb).forEach(el => { if (el) el.checked = true; });
    return;
  }

  // Se veio de uma faixa individual e "Todas" ainda está marcada, mas já não temos 4 faixas,
  // então desmarca "Todas" (não força re-marcar tudo).
  if (lastKey !== "all" && cbAll && cbAll.checked && buckets.length < 4){
    cbAll.checked = false;
  }

  // Se todas as faixas estiverem marcadas, ativa "Todas"
  if (cbAll && buckets.length === 4){
    cbAll.checked = true;
  }

  // Se o usuário desmarcou todas as faixas, volta para "Todas"
  // (evita ficar sem nenhum ponto no mapa)
  if (buckets.length === 0){
    if (cbAll) cbAll.checked = true;
    Object.values(cb).forEach(el => { if (el) el.checked = true; });
  }
}

// exposto para o wireTimeFilterEvents
      window.__getSelectedTimeBuckets = () => {
        const buckets = selectedBuckets();
        const allMode = (cbAll && cbAll.checked) || buckets.length === 0;
        return allMode ? ["yellow","green","orange","red"] : buckets;
      };

      function onMultiSelectChanged(lastKey){
        enforceRules(lastKey);
        updateLabel();
        syncHiddenChips();

        // Dispara o mesmo fluxo que o filtro de horário sempre usou
        if (typeof window.__onTimeFiltersChanged === "function"){
          window.__onTimeFiltersChanged();
        }
      }

      

      // reage a mudanças do filtro Bairro
      try{
        if (typeof bairroSelEl !== "undefined" && bairroSelEl){
          bairroSelEl.addEventListener("change", () => {
            syncTimeMsVisibility();
          });
        }
      }catch(e){}
      syncTimeMsVisibility();
      // Inicializa estado
      enforceRules("all");
      updateLabel();
      syncHiddenChips();
    }


// =========================
// SUPORTE A FILTROS: DIA DA SEMANA / MÊS (COMBOBOX MULTISELECT)
// Regras: aparecem apenas quando um bairro específico (≠ __all__) está selecionado.
// =========================

function monthKeyFromValue(v){
  if (v === null || v === undefined) return null;
  if (typeof v === "number" && Number.isFinite(v)){
    const n = Math.round(v);
    return (n >= 1 && n <= 12) ? n : null;
  }
  let s = String(v).trim();
  if (!s) return null;

  // tenta número primeiro
  const n = parseInt(s, 10);
  if (!isNaN(n) && n >= 1 && n <= 12) return n;

  // normaliza nomes (pt-br) e abreviações comuns
  const k = normalizeName(s);
  const map = {
    "JANEIRO":1, "JAN":1,
    "FEVEREIRO":2, "FEV":2,
    "MARCO":3, "MAR":3,
    "ABRIL":4, "ABR":4,
    "MAIO":5, "MAI":5,
    "JUNHO":6, "JUN":6,
    "JULHO":7, "JUL":7,
    "AGOSTO":8, "AGO":8,
    "SETEMBRO":9, "SET":9,
    "OUTUBRO":10, "OUT":10,
    "NOVEMBRO":11, "NOV":11,
    "DEZEMBRO":12, "DEZ":12
  };
  return map[k] || null;
}


// Normaliza qualquer representacao de dia da semana para as chaves SEG/TER/QUA/QUI/SEX/SAB/DOM.
// Aceita: SEG, TER, QUA, QUI, SEX, SAB, DOM; ou formatos por extenso.
// Retorna null se nao conseguir identificar.
function initMonthMultiSelect(){
  const ms = document.getElementById("monthMs");
  const btn = document.getElementById("monthMsBtn");
  const panel = document.getElementById("monthMsPanel");
  const valueEl = document.getElementById("monthMsValue");
  if (!ms || !btn || !panel || !valueEl) return;

  function syncVisibility(){
    const bairroSel = (typeof bairroSelEl !== "undefined" && bairroSelEl) ? bairroSelEl.value : null;
    const show = !!bairroSel && bairroSel !== "__all__";
    ms.style.display = show ? "inline-block" : "none";
    if (!show){
      ms.classList.remove("open");
      btn.setAttribute("aria-expanded","false");
      if (cbAll) cbAll.checked = true;
      Object.values(cb).forEach(el => { if (el) el.checked = true; });
      updateLabel();
    }
  }

  const cbAll = document.getElementById("mon_all");
  const cb = {};
  for (let i=1;i<=12;i++){
    cb[i] = document.getElementById("mon_"+i);
  }

  const monthNames = {1:"Jan",2:"Fev",3:"Mar",4:"Abr",5:"Mai",6:"Jun",7:"Jul",8:"Ago",9:"Set",10:"Out",11:"Nov",12:"Dez"};

  btn.addEventListener("click", (e) => {
    e.preventDefault();
    const open = ms.classList.toggle("open");
    btn.setAttribute("aria-expanded", open ? "true" : "false");
  });

  document.addEventListener("click", (e) => {
    if (!ms.classList.contains("open")) return;
    if (ms.contains(e.target)) return;
    ms.classList.remove("open");
    btn.setAttribute("aria-expanded", "false");
  });

  panel.addEventListener("click", (e) => {
    const row = e.target.closest(".ms-row");
    if (row && e.target.tagName !== "INPUT"){
      const input = row.querySelector("input[type='checkbox']");
      if (!input) return;
      input.checked = !input.checked;
      const k = row.getAttribute("data-ms");
      const kk = (k === "all") ? "all" : parseInt(k,10);
      onChanged(Number.isFinite(kk) ? kk : k);
    }
  });

  Object.values(cb).forEach((el, idx) => {
    if (!el) return;
    // idx aqui não é o mês, então extraímos do id mon_#
    const m = parseInt((el.id || "").replace("mon_",""),10);
    el.addEventListener("change", () => onChanged(Number.isFinite(m) ? m : "month"));
  });
  if (cbAll) cbAll.addEventListener("change", () => onChanged("all"));

  function selectedKeys(){
    return Object.keys(cb).map(k=>parseInt(k,10)).filter(k => cb[k] && cb[k].checked);
  }

  function enforceRules(lastKey){
  const total = 12;
  const keys = selectedKeys();

  // Regras:
  // - Se clicar em "Todos", marca Jan..Dez
  // - Se desmarcar qualquer mês individual, "Todos" é desmarcado
  // - Se marcar Jan..Dez individualmente, "Todos" é marcado

  // Clique direto em "Todos"
  if (lastKey === "all" && cbAll && cbAll.checked){
    Object.values(cb).forEach(el => { if (el) el.checked = true; });
    return;
  }

  // Se veio de um mês individual e "Todos" ainda está marcado, mas já não temos 12 meses,
  // então desmarca "Todos" (não força re-marcar tudo).
  if (lastKey !== "all" && cbAll && cbAll.checked && keys.length < total){
    cbAll.checked = false;
  }

  // Se todos os meses estiverem marcados individualmente, ativa "Todos"
  if (cbAll && keys.length === total){
    cbAll.checked = true;
  }

  // Se não sobrou nada marcado, volta para "Todos"
  if (keys.length === 0){
    if (cbAll) cbAll.checked = true;
    Object.values(cb).forEach(el => { if (el) el.checked = true; });
  }
}

function updateLabel(){
    const keys = selectedKeys();
    const allMode = (cbAll && cbAll.checked) || keys.length === 0;
    if (allMode){
      valueEl.textContent = "Todos";
      return;
    }
    if (keys.length <= 2){
      valueEl.textContent = keys.map(k => monthNames[k] || String(k)).join(", ");
      return;
    }
    valueEl.textContent = `${keys.length} meses`;
  }

  window.__getSelectedMonths = () => {
    const keys = selectedKeys();
    const allMode = (cbAll && cbAll.checked) || keys.length === 0;
    return allMode ? Object.keys(cb).map(k=>parseInt(k,10)) : keys;
  };

  function onChanged(lastKey){
    enforceRules(lastKey);
    updateLabel();
    if (typeof window.__onTimeFiltersChanged === "function"){
      window.__onTimeFiltersChanged();
    } else {
      updateMarkers();
      refreshAnyBairroPopup();
    }
  }

  try{
    if (typeof bairroSelEl !== "undefined" && bairroSelEl){
      bairroSelEl.addEventListener("change", syncVisibility);
    }
  }catch(e){}
  enforceRules("all");
  updateLabel();
  syncVisibility();
}

function wireTimeFilterEvents(){
      // Quando o usuário altera os chips de horário, precisamos:
      // 1) atualizar os pontos exibidos (markers) e
      // 2) atualizar o popup fixo do bairro para refletir o mesmo recorte.
      const onTimeFiltersChanged = () => {
        // Fecha qualquer popup aberto ao mexer nos horários
        try { map.closePopup(); } catch(e) {}
        try { openPopupRef = null; } catch(e) {}
        try { openPopupRegionKey = null; } catch(e) {}
        try { fixedPopupRef = null; } catch(e) {}
        try { fixedPopupRegionKey = null; } catch(e) {}
        updateMarkers();
        try{ refreshFixedPopup(); }catch(e){}
        try{ refreshAnyBairroPopup(); }catch(e){}
      };

      // expõe para o multiselect disparar o mesmo fluxo
      window.__onTimeFiltersChanged = onTimeFiltersChanged;
      if (!tfAll) return;

      const setActive = (btn, on) => {
        if (!btn) return;
        btn.classList.toggle("active", !!on);
        btn.setAttribute("aria-pressed", !!on ? "true" : "false");
      };

      const updateAllState = () => {
        const allOn =
          (!!tfYellow && tfYellow.classList.contains("active")) &&
          (!!tfGreen  && tfGreen.classList.contains("active")) &&
          (!!tfOrange && tfOrange.classList.contains("active")) &&
          (!!tfRed    && tfRed.classList.contains("active"));
        setActive(tfAll, allOn);
      };

      // Inicializa aria-pressed
      [tfAll, tfYellow, tfGreen, tfOrange, tfRed].forEach(b => {
        if (!b) return;
        b.setAttribute("aria-pressed", b.classList.contains("active") ? "true" : "false");
      });

      tfAll.addEventListener("click", () => {
        // "Todos" liga tudo
        setActive(tfAll, true);
        [tfYellow, tfGreen, tfOrange, tfRed].forEach(b => setActive(b, true));
        onTimeFiltersChanged();
      });

      const onSpecClick = (btn) => {
        // Toggle do chip específico
        const nowOn = !btn.classList.contains("active");
        setActive(btn, nowOn);

        // Se qualquer específico foi desligado, "Todos" deve desligar
        // Se todos específicos ligarem, "Todos" liga.
        updateAllState();
        onTimeFiltersChanged();
      };

      [tfYellow, tfGreen, tfOrange, tfRed].forEach(btn => {
        if (!btn) return;
        btn.addEventListener("click", () => onSpecClick(btn));
      });
    }


    function labelForHoraFato(hhmmss){
      const t = parseTimeToSeconds(hhmmss);
      if (!Number.isFinite(t)) return "—";
      const h = String(Math.floor(t / 3600)).padStart(2, "0");
      const m = String(Math.floor((t % 3600) / 60)).padStart(2, "0");
      const s = String(t % 60).padStart(2, "0");
      return `${h}:${m}:${s}`;
    }

    function setBusy(on){
      document.getElementById("busy").style.display = on ? "block" : "none";
    }

    const map = L.map('map').setView([-1.4558, -48.4902], 12);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    const districtLayers = {};
    const districtNameByKey = {};
    const popupLayer = L.layerGroup().addTo(map);
    const markersLayer = L.layerGroup().addTo(map);
    // --- controle de popup aberto (interativo) e popup fixo (bairro selecionado) ---
    let openPopupRef = null;
    let openPopupRegionKey = null;
    let fixedPopupRef = null;
    let fixedPopupRegionKey = null;

    const labelsLayer  = L.layerGroup().addTo(map);
    const polygonCache = {};

    const yearCachePerType = {};
    const yearCacheAll = {};

    const bairrosMeta = {};
    const distritoMeta = {};
    const bairroToDist = {};

    const pointsPerType = {};
    const pointsAll = {};

    let YEARS = [];
    let currentYear = null;

    async function loadCsv(path){
      return new Promise((resolve) => {
        Papa.parse(path, {
          header: true,
          download: true,
          dynamicTyping: true,
          complete: (res) => {
            const rows = (res.data || []).filter(r => r && r.ano && r.bairro);
            resolve(rows);
          },
          error: () => resolve([])
        });
      });
    }

    async function preloadCsvs(){
      const yearSet = new Set();

      for (const src of CSV_SOURCES){
        const rows = await loadCsv(src.path);
        const cache = {};
        const pts  = {};
        yearCachePerType[src.key] = cache;
        pointsPerType[src.key] = pts;

        for (const r of rows){
          const ano = parseInt(r.ano,10);
          if (!ano || isNaN(ano)) continue;

          const bairroRaw = r.bairro;
          if (!bairroRaw) continue;
          const bairroKey = normalizeName(bairroRaw);

          const distritoRaw = r.distrito || "";
          const distKey = distritoRaw ? normalizeName(distritoRaw) : "";

          yearSet.add(ano);

          if (!bairrosMeta[bairroKey]) {
            bairrosMeta[bairroKey] = {
              name: String(bairroRaw).trim(),
              distKey: distKey || null,
              distritoNome: distritoRaw ? String(distritoRaw).trim() : ""
            };
          }
          if (!bairroToDist[bairroKey] && distKey){
            bairroToDist[bairroKey] = distKey;
          }
          if (distKey && !distritoMeta[distKey]){
            distritoMeta[distKey] = { name: distritoRaw.trim() };
          }

          if (!cache[ano]) cache[ano] = { byRegion:{}, min:0, max:0 };
          const yearObj = cache[ano];
          if (!yearObj.byRegion[bairroKey]) yearObj.byRegion[bairroKey] = { total:0, byType:{} };
          const reg = yearObj.byRegion[bairroKey];
          reg.total += 1;
          reg.byType[src.label] = (reg.byType[src.label] || 0) + 1;

          const latVal = r.latitude ?? r.Latitude ?? r.LATITUDE ?? r.lat ?? r.Lat ?? r.LAT;
          const lngVal = r.longitude ?? r.Longitude ?? r.LONGITUDE ?? r.lon ?? r.lng ?? r.LON;

          const lat = parseNumber(latVal);
          const lng = parseNumber(lngVal);

          if (Number.isFinite(lat) && Number.isFinite(lng)){
            if (!pts[ano]) pts[ano] = [];
            const p = {
              lat, lng,
              ano,
              bairroRaw,
              bairroKey,
              distrito: distritoRaw,
              // CSVs no formato esperado (ex.: colunas "mes" e "dia"):
              //   mes: JANEIRO, FEVEREIRO, ... (em maiúsculas)
              //   dia: SEG, TER, QUA, QUI, SEX, SAB, DOM
              // Mantém compatibilidade com outros nomes de coluna já usados.
              mes: (getMesFromRow(r) ?? ""),
              mesKey: monthKeyFromValue(getMesFromRow(r) ?? ""),

              local: r.local_ocorrencia || "",
              horafato: r.horafato ?? r.HORA_FATO ?? r.HORAFATO ?? r.hora_fato ?? r.HoraFato ?? r.horaFato ?? "",
              typeKey: src.key,
              typeLabel: src.label
            };
            pts[ano].push(p);

            if (!pointsAll[ano]) pointsAll[ano] = [];
            pointsAll[ano].push(p);
          }
        }

        for (const [ano, obj] of Object.entries(cache)){
          const totals = Object.values(obj.byRegion).map(o => o.total);
          obj.min = totals.length ? Math.min(...totals) : 0;
          obj.max = totals.length ? Math.max(...totals) : 0;
        }
      }

      for (const src of CSV_SOURCES){
        const perType = yearCachePerType[src.key];
        for (const [ano, obj] of Object.entries(perType)){
          const anoNum = parseInt(ano,10);
          if (!yearCacheAll[anoNum]) yearCacheAll[anoNum] = { byRegion:{}, min:0, max:0 };
          const allYear = yearCacheAll[anoNum];

          for (const [bairroKey, reg] of Object.entries(obj.byRegion)){
            if (!allYear.byRegion[bairroKey]) allYear.byRegion[bairroKey] = { total:0, byType:{} };
            const dest = allYear.byRegion[bairroKey];
            dest.total += reg.total;
            for (const [lbl,v] of Object.entries(reg.byType)){
              dest.byType[lbl] = (dest.byType[lbl] || 0) + v;
            }
          }
        }
      }

      for (const [ano, obj] of Object.entries(yearCacheAll)){
        const totals = Object.values(obj.byRegion).map(o => o.total);
        obj.min = totals.length ? Math.min(...totals) : 0;
        obj.max = totals.length ? Math.max(...totals) : 0;
      }

      YEARS = Array.from(yearSet).sort((a,b)=>a-b);
      if (!YEARS.length) YEARS = [2024];
      currentYear = YEARS[YEARS.length - 1];
    }

    function flattenLatLngs(latlngs){
      if (!Array.isArray(latlngs)) return [];
      if (latlngs.length === 0) return [];
      if (latlngs[0] instanceof L.LatLng){
        return [latlngs];
      }
      let result = [];
      latlngs.forEach(sub => {
        result = result.concat(flattenLatLngs(sub));
      });
      return result;
    }

    function pointInPolygon(lat, lng, poly){
      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        const xi = poly[i][0], yi = poly[i][1];
        const xj = poly[j][0], yj = poly[j][1];

        const intersect = ((yi > lng) !== (yj > lng)) &&
                          (lat < (xj - xi) * (lng - yi) / (yj - yi + 1e-12) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function pointInAnyPolygon(lat, lng, bairroKey){
      const polys = polygonCache[bairroKey];
      if (!polys || !polys.length) return true;
      for (const poly of polys){
        if (pointInPolygon(lat, lng, poly)) return true;
      }
      return false;
    }

    async function loadAllKmls(){
      const keys = Object.keys(bairrosMeta);
      for (const key of keys){
        const meta = bairrosMeta[key];
        const file = KML_DIR + slug(meta.name) + ".kml";

        await new Promise((resolve) => {
          const group = omnivore.kml(encodeURI(file));
          group.on("ready", function(){
            const color = colorForRegion(key);
            applyStyle(group, color, 0.25);
            districtLayers[key] = group;
            districtNameByKey[key] = meta.name;

            const polygons = [];
            group.eachLayer(function(lyr){
              if (lyr.getLatLngs){
                const rings = flattenLatLngs(lyr.getLatLngs());
                rings.forEach(r => {
                  polygons.push(r.map(ll => [ll.lat, ll.lng]));
                });
              }
            });
            polygonCache[key] = polygons;

            group.eachLayer(function(lyr){
              lyr.on("click", (e) => {
                // fecha o popup fixo antes de abrir o novo (mantém o popup interativo como o "ativo")
                popupLayer.clearLayers();
                fixedPopupRef = null;
                fixedPopupRegionKey = null;

                const latlng = e.latlng || (lyr.getBounds ? lyr.getBounds().getCenter() : map.getCenter());
                openOrUpdateInteractivePopup(key, latlng);
              });
            });

            group.addTo(map);
            resolve();
          });
          group.on("error", function(){
            console.warn("Falha ao carregar KML:", file);
            resolve();
          });
        });
      }
    }

    function applyStyle(group, color, opacity){
      group.eachLayer(function(lyr){
        if (lyr.setStyle){
          lyr.setStyle({
            color: color,
            weight: 1.2,
            opacity: opacity,
            fillColor: color,
            fillOpacity: opacity
          });
        }
      });
    }

    function fitAllVisible(){
      try{
        const visible = [];
        for (const [key, group] of Object.entries(districtLayers)){
          if (map.hasLayer(group)) visible.push(group);
        }
        if (!visible.length) return;
        const fg = L.featureGroup(visible);
        map.fitBounds(fg.getBounds(), { padding:[20,20] });
      } catch(e){}
    }

    const distritoSelEl = document.getElementById("distritoSel");
    const bairroSelEl = document.getElementById("bairroSel");
    const pillToggle = document.getElementById("pillToggle");

    // --- filtros de horário (visível apenas quando bairro específico é selecionado) ---
    const timeFiltersEl = document.getElementById("timeFilters");
    const tfAll    = document.getElementById("tf_all");
    const tfYellow = document.getElementById("tf_yellow");
    const tfGreen  = document.getElementById("tf_green");
    const tfOrange = document.getElementById("tf_orange");
    const tfRed    = document.getElementById("tf_red");

    function buildYearSelect(){
      const sel = document.getElementById("anoSel");
      sel.innerHTML = "";
      YEARS.forEach(y => {
        const opt = document.createElement("option");
        opt.value = String(y);
        opt.textContent = String(y);
        sel.appendChild(opt);
      });
      sel.value = String(currentYear);
    }

    function buildDistritoSelect(){
      distritoSelEl.querySelectorAll("option:not([value='__all__'])").forEach(o => o.remove());
      const list = Object.entries(distritoMeta)
        .map(([key,val]) => ({ key, name: val.name }))
        .sort((a,b) => a.name.localeCompare(b.name,"pt-BR"));
      for (const item of list){
        const o = document.createElement("option");
        o.value = item.key;
        o.textContent = item.name;
        distritoSelEl.appendChild(o);
      }
    }

    function buildBairroSelect(){
      const distFilter = distritoSelEl.value;
      bairroSelEl.innerHTML = '<option value="__all__">Todos</option>';

      const list = Object.entries(bairrosMeta)
        .filter(([key,meta]) => {
          if (!distFilter || distFilter === "__all__") return true;
          return meta.distKey === distFilter;
        })
        .map(([key,val]) => ({ key, name: val.name }))
        .sort((a,b) => a.name.localeCompare(b.name,"pt-BR"));

      for (const item of list){
        const o = document.createElement("option");
        o.value = item.key;
        o.textContent = item.name;
        bairroSelEl.appendChild(o);
      }
      bairroSelEl.value = "__all__";
    }


    function buildConventionLegend(){
      const el = document.getElementById("convLegend");
      if (!el) return;

      el.innerHTML = [
        '<div class="conv-title">Convenções</div>',
        '<div class="conv-items">',
          '<div class="conv-item"><span class="box" style="background:#ffeb3b"></span><span>00:01–06:00</span></div>',
          '<div class="conv-item"><span class="box" style="background:#8bc34a"></span><span>06:01–12:00</span></div>',
          '<div class="conv-item"><span class="box" style="background:#ff9800"></span><span>12:01–18:00</span></div>',
          '<div class="conv-item"><span class="box" style="background:#ff0000"></span><span>18:01–00:00</span></div>',
        '</div>'
      ].join('');
    }

    function buildColorLegend(){
      const legend = document.getElementById("colorLegend");
      const itemsEl = document.getElementById("colorLegendItems");
      itemsEl.innerHTML = "";

      const bairroSel = bairroSelEl.value;
      const distFilter = distritoSelEl.value;

      if (bairroSel && bairroSel !== "__all__" && bairrosMeta[bairroSel]) {
        legend.classList.remove("two-cols");
        const meta = bairrosMeta[bairroSel];
        const c = colorForRegion(bairroSel);
        const div = document.createElement("div");
        div.className = "item";
        div.innerHTML = '<span class="box" style="background:'+c+'"></span><span>'+meta.name+'</span>';
        itemsEl.appendChild(div);
        return;
      }

      legend.classList.add("two-cols");
      const list = Object.entries(bairrosMeta)
        .filter(([key, meta]) => {
          if (!distFilter || distFilter === "__all__") return true;
          return meta.distKey === distFilter;
        })
        .map(([key,val]) => ({ key, name: val.name }))
        .sort((a,b) => a.name.localeCompare(b.name,"pt-BR"));

      list.forEach(item => {
        const c = colorForRegion(item.key);
        const div = document.createElement("div");
        div.className = "item";
        div.innerHTML = '<span class="box" style="background:'+c+'"></span><span>'+item.name+'</span>';
        itemsEl.appendChild(div);
      });
    }

    function getSelectedTypeKey(){
      return document.getElementById("tipoSel").value;
    }
    function getSelectedTypeLabel(){
      const k = getSelectedTypeKey();
      if (k === "__all__") return "Todas";
      const src = CSV_SOURCES.find(s => s.key === k);
      return src ? src.label : k;
    }
    function getActiveAgg(){
      const tipo = getSelectedTypeKey();
      if (tipo === "__all__") return yearCacheAll;
      return yearCachePerType[tipo] || {};
    }

    function updateDistrictVisibility() {
      const bairroSel = bairroSelEl.value;
      const distSel = distritoSelEl.value;

      for (const [key, group] of Object.entries(districtLayers)) {
        const meta = bairrosMeta[key];

        if (bairroSel && bairroSel !== "__all__") {
          if (key === bairroSel) {
            if (!map.hasLayer(group)) map.addLayer(group);
          } else {
            if (map.hasLayer(group)) map.removeLayer(group);
          }
          continue;
        }

        if (distSel !== "__all__" && meta.distKey !== distSel) {
          if (map.hasLayer(group)) map.removeLayer(group);
        } else {
          if (!map.hasLayer(group)) map.addLayer(group);
        }
      }

      fitAllVisible();
    }

    function applyFilters(){
      const aggAll = getActiveAgg()[currentYear] || { byRegion:{}, min:0, max:0 };
      let totalAno = 0;

      for (const [key, group] of Object.entries(districtLayers)){
        if (!map.hasLayer(group)) continue;
        const info = aggAll.byRegion[key];
        const value = info ? info.total : 0;
        totalAno += value;

        let opacity = 0.2;
        if (aggAll.max > aggAll.min && Number.isFinite(value)){
          const frac = (value - aggAll.min) / (aggAll.max - aggAll.min);
          opacity = 0.15 + frac * (0.9 - 0.15);
        } else if (aggAll.max === aggAll.min && aggAll.max > 0){
          opacity = 0.9;
        }
        applyStyle(group, colorForRegion(key), opacity);
      }

      document.getElementById("sumTotal").textContent = totalAno.toLocaleString("pt-BR");
      refreshFixedPopup();
      refreshAnyBairroPopup();
      syncTimeFiltersUI();
      updateMarkers();
      buildColorLegend();
      syncHandleToYear();
    }

    function buildPopupHtmlForRegion(key){
      // Popup do bairro refletindo filtros (tipo/ano/horário)
      const name = districtNameByKey[key] || (bairrosMeta[key] && bairrosMeta[key].name) || key;

      const tipoSelKey = getSelectedTypeKey();
      const tipoLabel  = getSelectedTypeLabel();
      const ano = currentYear;

      // Base de pontos para o ano/tipo selecionados
      let pts = [];
      if (tipoSelKey === "__all__"){
        pts = pointsAll[ano] || [];
      } else {
        pts = (pointsPerType[tipoSelKey] && pointsPerType[tipoSelKey][ano]) || [];
      }

      // Filtros de horário (chips)
      const buckets = getSelectedTimeBuckets();
      const useTimeFilter = Array.isArray(buckets) && buckets.length > 0;

      const monthsSel = getSelectedMonths();

      const monthActive = Array.isArray(monthsSel) && monthsSel.length > 0 && monthsSel.length < 12;

      // Agrega somente o bairro selecionado. Se nenhuma faixa estiver selecionada (e 'Todos' não estiver ativo),
      // o popup permanece com os números totais (sem filtro por horário).
      // Observação: NÃO filtramos por polígono aqui para manter a nota:
      // registros fora do limite do bairro são considerados no total, mas não exibidos como pontos.
      let total = 0;
      const byType = {};

      for (const p of pts){
        if (p.bairroKey !== key) continue;

        const mk = (p.mesKey ?? monthKeyFromValue(p.mes));
        if (monthActive){
          if (!mk) continue;
          if (!monthsSel.includes(mk)) continue;
        }

        const b = bucketForHoraFato(p.horafato);
        if (useTimeFilter && !buckets.includes(b)) continue;

        total += 1;
        const lbl = p.typeLabel || tipoLabel;
        byType[lbl] = (byType[lbl] || 0) + 1;
      }

      const rows = Object.entries(byType).sort((a,b)=>b[1]-a[1]);

      const table = rows.length
        ? '<table class="minimal"><thead><tr><th>Tipo</th><th>Ocorrências</th></tr></thead><tbody>'
          + rows.map(([label,val]) => '<tr><td>'+label+'</td><td>'+val+'</td></tr>').join("")
          + '</tbody></table>'
        : '<i>Sem detalhamento por tipo</i>';

      return [
        '<b>'+name+'</b>',
        '<div><b>Ano:</b> '+ano+'</div>',
        '<div><b>Tipo selecionado:</b> '+tipoLabel+'</div>',
        '<div><b>Total no ano:</b> '+total.toLocaleString("pt-BR")+'</div>',
        table+'<div style="font-size:10px;">*Registros cujas posições geográficas estão fora dos limites do bairro são considerados mas não são exibidos.</div>'
      ].join("");
    }

    
    // Abre/atualiza popup interativo (quando o usuário clica na área do bairro)
    function openOrUpdateInteractivePopup(regionKey, latlng){
      openPopupRegionKey = regionKey;
      const html = buildPopupHtmlForRegion(regionKey);

      if (openPopupRef && map.hasLayer(openPopupRef)){
        openPopupRef.setLatLng(latlng);
        openPopupRef.setContent(html);
      } else {
        openPopupRef = L.popup()
          .setLatLng(latlng)
          .setContent(html)
          .openOn(map);
      }
    }

    // Atualiza automaticamente qualquer popup de bairro que esteja aberto (interativo e/ou fixo)
    function refreshAnyBairroPopup(){
      // 1) popup interativo (clique no polígono)
      if (openPopupRef && openPopupRegionKey && map.hasLayer(openPopupRef)){
        openPopupRef
          .setContent(buildPopupHtmlForRegion(openPopupRegionKey))
          .update(); // força redesenho do popup aberto
      }

      // 2) popup fixo (bairro selecionado no combobox)
      if (fixedPopupRef && fixedPopupRegionKey && map.hasLayer(fixedPopupRef)){
        fixedPopupRef
          .setContent(buildPopupHtmlForRegion(fixedPopupRegionKey))
          .update(); // força redesenho do popup aberto
      }
    }

function refreshFixedPopup(){
      popupLayer.clearLayers();
      const bairroSel = bairroSelEl.value;
      if (!bairroSel || bairroSel === "__all__") {
        fixedPopupRef = null;
        fixedPopupRegionKey = null;
        return;
      }

      const group = districtLayers[bairroSel];
      if (!group || !map.hasLayer(group)) {
        fixedPopupRef = null;
        fixedPopupRegionKey = null;
        return;
      }

      let center;
      try { center = group.getBounds().getCenter(); }
      catch(e){ center = map.getCenter(); }

      fixedPopupRegionKey = bairroSel;
      const html = buildPopupHtmlForRegion(bairroSel);

      if (fixedPopupRef) {
        fixedPopupRef.setLatLng(center);
        fixedPopupRef.setContent(html);
      } else {
        fixedPopupRef = L.popup({ autoClose:false, closeOnClick:false, closeButton:false, className:"auto-popup" })
          .setLatLng(center)
          .setContent(html);
      }

      popupLayer.addLayer(fixedPopupRef);
    }

    function buildMarkerPopupHtml(p){
      const partes = [];
      partes.push('<b>'+p.typeLabel+'</b>');
      partes.push('<div><b>Ano:</b> '+p.ano+'</div>');
      if (p.mes) partes.push('<div><b>Mês:</b> '+p.mes+'</div>');
      if (p.bairroRaw) partes.push('<div><b>Bairro:</b> '+p.bairroRaw+'</div>');
      if (p.distrito) partes.push('<div><b>Distrito:</b> '+p.distrito+'</div>');
      if (p.horafato) partes.push('<div><b>Hora do fato:</b> '+labelForHoraFato(p.horafato)+'</div>');
      if (p.local) partes.push('<div><b>Local da ocorrência:</b> '+p.local+'</div>');
      return partes.join("");
    }

    function updateMarkers(){
      markersLayer.clearLayers();
      const bairroSel = bairroSelEl.value;

      if (!bairroSel || bairroSel === "__all__") return;

      const tipo = getSelectedTypeKey();
      const ano  = currentYear;
      let pts = [];

      if (tipo === "__all__"){
        pts = pointsAll[ano] || [];
      } else {
        pts = (pointsPerType[tipo] && pointsPerType[tipo][ano]) || [];
      }

      pts.forEach(p => {
        if (p.bairroKey !== bairroSel) return;

        const monthsSel = getSelectedMonths();

const monthSet = new Set(Array.isArray(monthsSel) ? monthsSel : []);

const monthActive = monthSet.size > 0 && monthSet.size < 12;

const mk = (p.mesKey ?? monthKeyFromValue(p.mes));
if (monthActive){
  if (!mk) return;
  if (!monthSet.has(mk)) return;
}

// Usa a chave já calculada na carga. Se faltar, tenta derivar da string bruta.

const buckets = getSelectedTimeBuckets();
        const b = bucketForHoraFato(p.horafato);
        if (buckets.length === 0) return;
        if (!buckets.includes(b)) return;
        if (!Number.isFinite(p.lat) || !Number.isFinite(p.lng)) return;
        if (!pointInAnyPolygon(p.lat, p.lng, bairroSel)) return;

        const c = colorForHoraFato(p.horafato);

        const marker = L.circleMarker([p.lat, p.lng], {
          radius: 6,
          color: c,
          fillColor: c,
          weight: 1,
          opacity: 1,
          fillOpacity: 0.9
        });

        marker.bindPopup(buildMarkerPopupHtml(p));
        markersLayer.addLayer(marker);
      });

      markersLayer.bringToFront();
    }

    function updateRegionLabels(){
      labelsLayer.clearLayers();

      if (!pillToggle || !pillToggle.checked) return;

      const bairroSel = bairroSelEl.value;
      const agg = getActiveAgg()[currentYear] || { byRegion:{} };

      if (bairroSel && bairroSel !== "__all__") {
        return;
      }

      for (const [key, group] of Object.entries(districtLayers)){
        if (!map.hasLayer(group)) continue;

        const info = agg.byRegion[key];
        const total = info ? info.total : 0;
        if (!total || total <= 0) continue;

        let center;
        try { center = group.getBounds().getCenter(); }
        catch(e){ continue; }

        const html = '<div class="region-pill">'+total.toLocaleString("pt-BR")+'</div>';

        const marker = L.marker(center, {
          icon: L.divIcon({
            html: html,
            className: 'region-pill-wrapper',
            iconSize: null
          })
        });

        labelsLayer.addLayer(marker);
      }
    }

    function updatePillToggleState() {
      const bairro = bairroSelEl.value;

      if (bairro === "__all__") {
        pillToggle.disabled = false;
      } else {
        pillToggle.disabled = true;
        pillToggle.checked = false;
      }

      updateRegionLabels();
    }

    function refreshAll(){
      applyFilters();
      updateRegionLabels();
    }

    const track = document.getElementById("track");
    const handle = document.getElementById("handle");
    const ticks = document.getElementById("ticks");

    function buildTicks(){
      ticks.innerHTML = YEARS.map(y => '<div class="year">'+y+'</div>').join("");
    }

    function syncHandleToYear(){
      const idx = YEARS.indexOf(currentYear);
      if (idx < 0 || YEARS.length === 1){
        handle.style.left = "0%";
        return;
      }
      const pct = (idx / (YEARS.length - 1)) * 100;
      handle.style.left = pct + "%";
    }

    function yearFromPosition(px){
      const rect = track.getBoundingClientRect();
      const clamped = Math.max(rect.left, Math.min(px, rect.right));
      const frac = (clamped - rect.left) / rect.width;
      const idx = Math.round(frac * (YEARS.length - 1));
      return YEARS[idx];
    }

    function setYearFromPx(px){
      const y = yearFromPosition(px);
      currentYear = y;

      const anoSelEl = document.getElementById("anoSel");
      if (anoSelEl.value !== String(y)) {
        anoSelEl.value = String(y);
      }

      syncHandleToYear();
      refreshAll();
    }

    function initTimelineDrag(){
      let dragging = false;

      const onDown = (e) => {
        dragging = true;
        document.body.style.userSelect = "none";
        const clientX = e.clientX ?? (e.touches && e.touches[0].clientX);
        setYearFromPx(clientX);
      };

      const onMove = (e) => {
        if (!dragging) return;
        const clientX = e.clientX ?? (e.touches && e.touches[0].clientX);
        setYearFromPx(clientX);
      };

      const onUp = () => {
        dragging = false;
        document.body.style.userSelect = "";
      };

      handle.addEventListener("mousedown", onDown);
      handle.addEventListener("touchstart", onDown, { passive:true });
      window.addEventListener("mousemove", onMove);
      window.addEventListener("touchmove", onMove, { passive:true });
      window.addEventListener("mouseup", onUp);
      window.addEventListener("touchend", onUp);

      track.addEventListener("mousedown", (e) => setYearFromPx(e.clientX));
      track.addEventListener("touchstart", (e) => setYearFromPx(e.touches[0].clientX), { passive:true });
    }

    // NOVA LÓGICA DE COLAPSAR LEGENDA
    const legendEl = document.getElementById("colorLegend");
    const legendBtn = document.getElementById("legendBtn");
    const legendHeader = document.getElementById("legendHeader");

    function toggleLegend() {
      const collapsed = legendEl.classList.toggle("collapsed");
      legendBtn.textContent = collapsed ? "▲" : "▼";
    }

    legendHeader.addEventListener("click", toggleLegend);

    (async function init(){
      try{
        setBusy(true);
        await preloadCsvs();
        await loadAllKmls();
        buildYearSelect();
        buildDistritoSelect();
        buildBairroSelect();
        buildTicks();
        buildConventionLegend();
        syncHandleToYear();
        updateDistrictVisibility();
        refreshAll();
        fitAllVisible();
        initTimelineDrag();
        updatePillToggleState();

        document.getElementById("tipoSel").addEventListener("change", () => {
          refreshAll();
        });

        document.getElementById("anoSel").addEventListener("change", () => {
          const val = document.getElementById("anoSel").value;
          const y = parseInt(val,10);
          if (!isNaN(y)) {
            currentYear = y;
          }
          syncHandleToYear();
          refreshAll();
        });

        distritoSelEl.addEventListener("change", () => {
          buildBairroSelect();
          updateDistrictVisibility();
          updatePillToggleState();
          syncTimeFiltersUI();
          refreshAll();
        });

        bairroSelEl.addEventListener("change", () => {
          updateDistrictVisibility();
          updatePillToggleState();
          syncTimeFiltersUI();
          refreshAll();
        });

        wireTimeFilterEvents();
      initTimeMultiSelect();
      initMonthMultiSelect();
        syncTimeFiltersUI();

        pillToggle.addEventListener("change", () => {
          updateRegionLabels();
        });

        document.getElementById("btnReset").addEventListener("click", () => {
          document.getElementById("tipoSel").value = "__all__";
          distritoSelEl.value = "__all__";
          buildBairroSelect();
          bairroSelEl.value = "__all__";
          currentYear = YEARS[YEARS.length - 1];
          document.getElementById("anoSel").value = String(currentYear);
          popupLayer.clearLayers();
          updateDistrictVisibility();
          updatePillToggleState();
          syncTimeFiltersUI();
          refreshAll();
        });

      } finally {
        setBusy(false);
      }
    })();
  </script>
</body>
</html>